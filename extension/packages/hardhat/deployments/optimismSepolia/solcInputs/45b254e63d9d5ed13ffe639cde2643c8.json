{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param chainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(uint64 chainSelector) external view returns (bool supported);\n\n  /// @notice Gets a list of all supported tokens which can be sent or received\n  /// to/from a given chain id.\n  /// @param chainSelector The chainSelector.\n  /// @return tokens The addresses of all tokens that are supported.\n  function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/SenderWithMsg.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\r\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\r\nimport {IERC20} from \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\r\n\r\ncontract SenderWithMsg {\r\n  \r\n    // Event emitted when a message is sent to another chain.\r\n    event MessageSent(\r\n        bytes32 indexed messageId, // The unique ID of the CCIP message.\r\n        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.\r\n        address receiver, // The address of the receiver on the destination chain.\r\n        string text, // The text being sent.\r\n        uint256 fees // The fees paid for sending the CCIP message.\r\n    );\r\n\r\n    event TokensTransferred(\r\n        bytes32 indexed messageId, // The unique ID of the message.\r\n        uint64 indexed destinationChainSelector, // The chain selector of the destination chain.\r\n        address receiver, // The address of the receiver on the destination chain.\r\n        uint256 fees // The fees paid for sending the message.\r\n    );\r\n\r\n    IRouterClient private router;\r\n    IERC20 private linkToken;\r\n\r\n    constructor(address _router, address _link) {\r\n        router = IRouterClient(_router);\r\n        linkToken = IERC20(_link);\r\n    }\r\n   \r\n    function transferToken2AnyChain(\r\n        uint64 _destinationChain,\r\n        address _token,\r\n        address _receiver,\r\n        uint256 _amount\r\n    )\r\n        external\r\n        returns (bytes32 messageId)\r\n    {\r\n        //Initialize variables\r\n        IERC20 token = IERC20(_token);\r\n\r\n        Client.EVMTokenAmount[]\r\n            memory tokenAmounts = new Client.EVMTokenAmount[](1);\r\n        Client.EVMTokenAmount memory tokenAmount = Client.EVMTokenAmount({\r\n            token: _token,\r\n            amount: _amount\r\n        });\r\n        tokenAmounts[0] = tokenAmount;\r\n\r\n        // Build the CCIP Message\r\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\r\n            receiver: abi.encode(_receiver),\r\n            data: \"\",\r\n            tokenAmounts: tokenAmounts,\r\n            extraArgs: Client._argsToBytes(\r\n                Client.EVMExtraArgsV1({gasLimit: 0})\r\n            ),\r\n            feeToken: address(linkToken)\r\n        });\r\n       \r\n        // CCIP Fees Management\r\n        uint256 fees = router.getFee(_destinationChain, message);\r\n\r\n        // Transfer tokens from user this contract\r\n        require(linkToken.transferFrom(msg.sender, address(this), fees), \"Couldnt transfer Link\");\r\n        require(token.transferFrom(msg.sender, address(this), _amount), \"Couldnt transfer token\");\r\n        \r\n        // Approve Router to spend tokens we send\r\n        linkToken.approve(address(router), fees);\r\n        IERC20(_token).approve(address(router), _amount);\r\n       \r\n        // Send CCIP Message\r\n        messageId = router.ccipSend(_destinationChain, message);\r\n       \r\n        emit TokensTransferred(\r\n            messageId,\r\n            _destinationChain,\r\n            _receiver,\r\n            fees\r\n        );\r\n    }\r\n\r\n    function sendMessage(\r\n        uint64 destinationChainSelector,\r\n        address receiver,\r\n        string calldata text\r\n    ) external returns (bytes32 messageId) {\r\n        // Create an EVM2AnyMessage struct in memory with necessary information for sending a cross-chain message\r\n        Client.EVM2AnyMessage memory evm2AnyMessage = Client.EVM2AnyMessage({\r\n            receiver: abi.encode(receiver), // ABI-encoded receiver address\r\n            data: abi.encode(text), // ABI-encoded string\r\n            tokenAmounts: new Client.EVMTokenAmount[](0), // Empty array indicating no tokens are being sent\r\n            extraArgs: Client._argsToBytes(\r\n                // Additional arguments, setting gas limit\r\n                Client.EVMExtraArgsV1({gasLimit: 200_000})\r\n            ),\r\n            // Set the feeToken  address, indicating LINK will be used for fees\r\n            feeToken: address(linkToken)\r\n        });\r\n\r\n        // Get the fee required to send the message\r\n        uint256 fees = router.getFee(\r\n            destinationChainSelector,\r\n            evm2AnyMessage\r\n        );\r\n\r\n        // Transfer tokens from user this contract\r\n        require(linkToken.transferFrom(msg.sender, address(this), fees), \"Couldnt transfer Link\");\r\n        \r\n        // Approve the Router to transfer LINK tokens on contract's behalf. It will spend the fees in LINK\r\n        linkToken.approve(address(router), fees);\r\n\r\n        // Send the message through the router and store the returned message ID\r\n        messageId = router.ccipSend(destinationChainSelector, evm2AnyMessage);\r\n\r\n        // Emit an event with message details\r\n        emit MessageSent(\r\n            messageId,\r\n            destinationChainSelector,\r\n            receiver,\r\n            text,\r\n            fees\r\n        );\r\n\r\n        // Return the message ID\r\n        return messageId;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}