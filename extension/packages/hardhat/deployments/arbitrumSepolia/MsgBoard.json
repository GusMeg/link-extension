{
  "address": "0x0a0b888B742E7c6125eF4897cA4ffB5426d07AC8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_router",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "router",
          "type": "address"
        }
      ],
      "name": "InvalidRouter",
      "type": "error"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes32",
              "name": "messageId",
              "type": "bytes32"
            },
            {
              "internalType": "uint64",
              "name": "sourceChainSelector",
              "type": "uint64"
            },
            {
              "internalType": "bytes",
              "name": "sender",
              "type": "bytes"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "token",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct Client.EVMTokenAmount[]",
              "name": "destTokenAmounts",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct Client.Any2EVMMessage",
          "name": "message",
          "type": "tuple"
        }
      ],
      "name": "ccipReceive",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCount",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getRouter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "count",
          "type": "uint256"
        }
      ],
      "name": "readMsg",
      "outputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "newMsg",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xec150d9f6642a8722eb713276abe3a9d1734a104ae8cb37848251791dd82666f",
  "receipt": {
    "to": null,
    "from": "0x0044fEbBf3dDF4204A644A92827635D6199966f8",
    "contractAddress": "0x0a0b888B742E7c6125eF4897cA4ffB5426d07AC8",
    "transactionIndex": 2,
    "gasUsed": "550937",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9f6da10caba09fffc5262bf7835c9b139c34aed30bbcc24b5a47ad5cca0010c0",
    "transactionHash": "0xec150d9f6642a8722eb713276abe3a9d1734a104ae8cb37848251791dd82666f",
    "logs": [],
    "blockNumber": 76630867,
    "cumulativeGasUsed": "639019",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x2a9C5afB0d0e4BAb2BCdaE109EC4b0c4Be15a165"
  ],
  "numDeployments": 2,
  "solcInputHash": "1e0ed871c787ab7241cddba0a78d6829",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"name\":\"InvalidRouter\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"messageId\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"sourceChainSelector\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"sender\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct Client.EVMTokenAmount[]\",\"name\":\"destTokenAmounts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Client.Any2EVMMessage\",\"name\":\"message\",\"type\":\"tuple\"}],\"name\":\"ccipReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"readMsg\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"newMsg\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"ccipReceive((bytes32,uint64,bytes,bytes,(address,uint256)[]))\":{\"details\":\"Note ensure you check the msg.sender is the OffRampRouter\",\"params\":{\"message\":\"CCIP Message\"}},\"getRouter()\":{\"returns\":{\"_0\":\"CCIP router address\"}},\"supportsInterface(bytes4)\":{\"details\":\"Should indicate whether the contract implements IAny2EVMMessageReceiver e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId This allows CCIP to check if ccipReceive is available before calling it. If this returns false or reverts, only tokens are transferred to the receiver. If this returns true, tokens are transferred and ccipReceive is called atomically. Additionally, if the receiver address does not have code associated with it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\",\"params\":{\"interfaceId\":\"The interfaceId to check\"},\"returns\":{\"_0\":\"true if the interfaceId is supported\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"ccipReceive((bytes32,uint64,bytes,bytes,(address,uint256)[]))\":{\"notice\":\"Called by the Router to deliver a message. If this reverts, any token transfers also revert. The message will move to a FAILED state and become available for manual execution.\"},\"getRouter()\":{\"notice\":\"Return the current router\"},\"supportsInterface(bytes4)\":{\"notice\":\"IERC165 supports an interfaceId\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MsgBoard.sol\":\"MsgBoard\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {IAny2EVMMessageReceiver} from \\\"../interfaces/IAny2EVMMessageReceiver.sol\\\";\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\nimport {IERC165} from \\\"../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\\n  address internal immutable i_ccipRouter;\\n\\n  constructor(address router) {\\n    if (router == address(0)) revert InvalidRouter(address(0));\\n    i_ccipRouter = router;\\n  }\\n\\n  /// @notice IERC165 supports an interfaceId\\n  /// @param interfaceId The interfaceId to check\\n  /// @return true if the interfaceId is supported\\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\\n  /// This allows CCIP to check if ccipReceive is available before calling it.\\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\\n  /// Additionally, if the receiver address does not have code associated with\\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\\n  }\\n\\n  /// @inheritdoc IAny2EVMMessageReceiver\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external virtual override onlyRouter {\\n    _ccipReceive(message);\\n  }\\n\\n  /// @notice Override this function in your implementation.\\n  /// @param message Any2EVMMessage\\n  function _ccipReceive(Client.Any2EVMMessage memory message) internal virtual;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  // Plumbing\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Return the current router\\n  /// @return CCIP router address\\n  function getRouter() public view returns (address) {\\n    return address(i_ccipRouter);\\n  }\\n\\n  error InvalidRouter(address router);\\n\\n  /// @dev only calls from the set router are accepted.\\n  modifier onlyRouter() {\\n    if (msg.sender != address(i_ccipRouter)) revert InvalidRouter(msg.sender);\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x23827b8b1cd9f1d7886720ab0347d34891c4a584dc9ee048b85a41dc2241917f\",\"license\":\"MIT\"},\"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {Client} from \\\"../libraries/Client.sol\\\";\\n\\n/// @notice Application contracts that intend to receive messages from\\n/// the router should implement this interface.\\ninterface IAny2EVMMessageReceiver {\\n  /// @notice Called by the Router to deliver a message.\\n  /// If this reverts, any token transfers also revert. The message\\n  /// will move to a FAILED state and become available for manual execution.\\n  /// @param message CCIP Message\\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\\n  function ccipReceive(Client.Any2EVMMessage calldata message) external;\\n}\\n\",\"keccak256\":\"0xd2a05a4f58a453cbf8cfa6aa78f58cb8e42091b3a025f711a0aa51f584e16b48\",\"license\":\"MIT\"},\"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// End consumer library.\\nlibrary Client {\\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\\n  struct EVMTokenAmount {\\n    address token; // token address on the local chain.\\n    uint256 amount; // Amount of tokens.\\n  }\\n\\n  struct Any2EVMMessage {\\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\\n    uint64 sourceChainSelector; // Source chain selector.\\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\\n    bytes data; // payload sent in original message.\\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\\n  }\\n\\n  // If extraArgs is empty bytes, the default is 200k gas limit.\\n  struct EVM2AnyMessage {\\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\\n    bytes data; // Data payload\\n    EVMTokenAmount[] tokenAmounts; // Token transfers\\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV1)\\n  }\\n\\n  // bytes4(keccak256(\\\"CCIP EVMExtraArgsV1\\\"));\\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\\n  struct EVMExtraArgsV1 {\\n    uint256 gasLimit;\\n  }\\n\\n  function _argsToBytes(EVMExtraArgsV1 memory extraArgs) internal pure returns (bytes memory bts) {\\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\\n  }\\n}\\n\",\"keccak256\":\"0x8af3ac1085c87342373772fb1a0107c7b90258e6bfed318ab2a601a14477e679\",\"license\":\"MIT\"},\"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\",\"keccak256\":\"0xa36a31b4bb17fad88d023474893b3b895fa421650543b1ce5aefc78efbd43244\",\"license\":\"MIT\"},\"contracts/MsgBoard.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport {Client} from \\\"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\\\";\\r\\nimport {CCIPReceiver} from \\\"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\\\";\\r\\n\\r\\nstruct Msg {\\r\\n    uint64 from;\\r\\n    address sender;\\r\\n    string message;\\r\\n}\\r\\n\\r\\ncontract MsgBoard is CCIPReceiver{\\r\\n    mapping(uint256 => Msg) msgDashboard;\\r\\n    uint256 msgCount;\\r\\n\\r\\n    constructor(address _router) CCIPReceiver(_router){}\\r\\n\\r\\n    function _ccipReceive(\\r\\n        Client.Any2EVMMessage memory any2EvmMessage\\r\\n    ) internal override {\\r\\n        address sender = abi.decode(any2EvmMessage.sender, (address));\\r\\n        string memory message = abi.decode(any2EvmMessage.data, (string));\\r\\n        uint64 from = any2EvmMessage.sourceChainSelector;\\r\\n        msgDashboard[msgCount] = Msg(from, sender, message);\\r\\n        msgCount++;\\r\\n    }\\r\\n\\r\\n    function getCount() external view returns(uint256){\\r\\n        return msgCount;\\r\\n    }\\r\\n\\r\\n    function readMsg(uint256 count) external view returns(address sender, string memory newMsg){\\r\\n        sender = msgDashboard[count].sender;\\r\\n        newMsg = msgDashboard[count].message;\\r\\n    }\\r\\n}\",\"keccak256\":\"0x3d778b9230b5f779f62e981711e4a25795ce5db2a8ed5d47ebc07089500b7bbd\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b506040516109b23803806109b283398101604081905261002f91610070565b806001600160a01b03811661005e576040516335fdcccd60e21b81526000600482015260240160405180910390fd5b6001600160a01b0316608052506100a0565b60006020828403121561008257600080fd5b81516001600160a01b038116811461009957600080fd5b9392505050565b6080516108f16100c16000396000818160b7015261014401526108f16000f3fe608060405234801561001057600080fd5b50600436106100575760003560e01c806301ffc9a71461005c57806385572ffb14610084578063a87d942c14610099578063b0f479a1146100aa578063bd682370146100e1575b600080fd5b61006f61006a36600461032f565b610102565b60405190151581526020015b60405180910390f35b610097610092366004610360565b610139565b005b60015460405190815260200161007b565b6040516001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815260200161007b565b6100f46100ef36600461039b565b61019c565b60405161007b9291906103d8565b60006001600160e01b031982166385572ffb60e01b148061013357506001600160e01b031982166301ffc9a760e01b145b92915050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610188576040516335fdcccd60e21b815233600482015260240160405180910390fd5b6101996101948261060a565b610257565b50565b6000818152602081905260409020805460019091018054600160401b9092046001600160a01b031691606091906101d2906106b7565b80601f01602080910402602001604051908101604052809291908181526020018280546101fe906106b7565b801561024b5780601f106102205761010080835404028352916020019161024b565b820191906000526020600020905b81548152906001019060200180831161022e57829003601f168201915b50505050509050915091565b6000816040015180602001905181019061027191906106f1565b90506000826060015180602001905181019061028d919061070e565b6020808501516040805160608101825267ffffffffffffffff80841682526001600160a01b038089168387019081528385018881526001805460009081529889905295909720845181549251909316600160401b026001600160e01b03199092169290931691909117178155935194955091939192919082019061031190826107d4565b5050600180549150600061032483610894565b919050555050505050565b60006020828403121561034157600080fd5b81356001600160e01b03198116811461035957600080fd5b9392505050565b60006020828403121561037257600080fd5b813567ffffffffffffffff81111561038957600080fd5b820160a0818503121561035957600080fd5b6000602082840312156103ad57600080fd5b5035919050565b60005b838110156103cf5781810151838201526020016103b7565b50506000910152565b60018060a01b038316815260406020820152600082518060408401526104058160608501602087016103b4565b601f01601f1916919091016060019392505050565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156104535761045361041a565b60405290565b60405160a0810167ffffffffffffffff811182821017156104535761045361041a565b604051601f8201601f1916810167ffffffffffffffff811182821017156104a5576104a561041a565b604052919050565b803567ffffffffffffffff811681146104c557600080fd5b919050565b600067ffffffffffffffff8211156104e4576104e461041a565b50601f01601f191660200190565b600082601f83011261050357600080fd5b8135610516610511826104ca565b61047c565b81815284602083860101111561052b57600080fd5b816020850160208301376000918101602001919091529392505050565b6001600160a01b038116811461019957600080fd5b600082601f83011261056e57600080fd5b8135602067ffffffffffffffff82111561058a5761058a61041a565b610598818360051b0161047c565b82815260069290921b840181019181810190868411156105b757600080fd5b8286015b848110156105ff57604081890312156105d45760008081fd5b6105dc610430565b81356105e781610548565b815281850135858201528352918301916040016105bb565b509695505050505050565b600060a0823603121561061c57600080fd5b610624610459565b82358152610634602084016104ad565b6020820152604083013567ffffffffffffffff8082111561065457600080fd5b610660368387016104f2565b6040840152606085013591508082111561067957600080fd5b610685368387016104f2565b6060840152608085013591508082111561069e57600080fd5b506106ab3682860161055d565b60808301525092915050565b600181811c908216806106cb57607f821691505b6020821081036106eb57634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561070357600080fd5b815161035981610548565b60006020828403121561072057600080fd5b815167ffffffffffffffff81111561073757600080fd5b8201601f8101841361074857600080fd5b8051610756610511826104ca565b81815285602083850101111561076b57600080fd5b61077c8260208301602086016103b4565b95945050505050565b601f8211156107cf57600081815260208120601f850160051c810160208610156107ac5750805b601f850160051c820191505b818110156107cb578281556001016107b8565b5050505b505050565b815167ffffffffffffffff8111156107ee576107ee61041a565b610802816107fc84546106b7565b84610785565b602080601f831160018114610837576000841561081f5750858301515b600019600386901b1c1916600185901b1785556107cb565b600085815260208120601f198616915b8281101561086657888601518255948401946001909101908401610847565b50858210156108845787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000600182016108b457634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220136fa34115cc42ce3696aec9e8210afd936aa6822bedc7b095d77d86d4b8887d64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100575760003560e01c806301ffc9a71461005c57806385572ffb14610084578063a87d942c14610099578063b0f479a1146100aa578063bd682370146100e1575b600080fd5b61006f61006a36600461032f565b610102565b60405190151581526020015b60405180910390f35b610097610092366004610360565b610139565b005b60015460405190815260200161007b565b6040516001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016815260200161007b565b6100f46100ef36600461039b565b61019c565b60405161007b9291906103d8565b60006001600160e01b031982166385572ffb60e01b148061013357506001600160e01b031982166301ffc9a760e01b145b92915050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610188576040516335fdcccd60e21b815233600482015260240160405180910390fd5b6101996101948261060a565b610257565b50565b6000818152602081905260409020805460019091018054600160401b9092046001600160a01b031691606091906101d2906106b7565b80601f01602080910402602001604051908101604052809291908181526020018280546101fe906106b7565b801561024b5780601f106102205761010080835404028352916020019161024b565b820191906000526020600020905b81548152906001019060200180831161022e57829003601f168201915b50505050509050915091565b6000816040015180602001905181019061027191906106f1565b90506000826060015180602001905181019061028d919061070e565b6020808501516040805160608101825267ffffffffffffffff80841682526001600160a01b038089168387019081528385018881526001805460009081529889905295909720845181549251909316600160401b026001600160e01b03199092169290931691909117178155935194955091939192919082019061031190826107d4565b5050600180549150600061032483610894565b919050555050505050565b60006020828403121561034157600080fd5b81356001600160e01b03198116811461035957600080fd5b9392505050565b60006020828403121561037257600080fd5b813567ffffffffffffffff81111561038957600080fd5b820160a0818503121561035957600080fd5b6000602082840312156103ad57600080fd5b5035919050565b60005b838110156103cf5781810151838201526020016103b7565b50506000910152565b60018060a01b038316815260406020820152600082518060408401526104058160608501602087016103b4565b601f01601f1916919091016060019392505050565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156104535761045361041a565b60405290565b60405160a0810167ffffffffffffffff811182821017156104535761045361041a565b604051601f8201601f1916810167ffffffffffffffff811182821017156104a5576104a561041a565b604052919050565b803567ffffffffffffffff811681146104c557600080fd5b919050565b600067ffffffffffffffff8211156104e4576104e461041a565b50601f01601f191660200190565b600082601f83011261050357600080fd5b8135610516610511826104ca565b61047c565b81815284602083860101111561052b57600080fd5b816020850160208301376000918101602001919091529392505050565b6001600160a01b038116811461019957600080fd5b600082601f83011261056e57600080fd5b8135602067ffffffffffffffff82111561058a5761058a61041a565b610598818360051b0161047c565b82815260069290921b840181019181810190868411156105b757600080fd5b8286015b848110156105ff57604081890312156105d45760008081fd5b6105dc610430565b81356105e781610548565b815281850135858201528352918301916040016105bb565b509695505050505050565b600060a0823603121561061c57600080fd5b610624610459565b82358152610634602084016104ad565b6020820152604083013567ffffffffffffffff8082111561065457600080fd5b610660368387016104f2565b6040840152606085013591508082111561067957600080fd5b610685368387016104f2565b6060840152608085013591508082111561069e57600080fd5b506106ab3682860161055d565b60808301525092915050565b600181811c908216806106cb57607f821691505b6020821081036106eb57634e487b7160e01b600052602260045260246000fd5b50919050565b60006020828403121561070357600080fd5b815161035981610548565b60006020828403121561072057600080fd5b815167ffffffffffffffff81111561073757600080fd5b8201601f8101841361074857600080fd5b8051610756610511826104ca565b81815285602083850101111561076b57600080fd5b61077c8260208301602086016103b4565b95945050505050565b601f8211156107cf57600081815260208120601f850160051c810160208610156107ac5750805b601f850160051c820191505b818110156107cb578281556001016107b8565b5050505b505050565b815167ffffffffffffffff8111156107ee576107ee61041a565b610802816107fc84546106b7565b84610785565b602080601f831160018114610837576000841561081f5750858301515b600019600386901b1c1916600185901b1785556107cb565b600085815260208120601f198616915b8281101561086657888601518255948401946001909101908401610847565b50858210156108845787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000600182016108b457634e487b7160e01b600052601160045260246000fd5b506001019056fea2646970667358221220136fa34115cc42ce3696aec9e8210afd936aa6822bedc7b095d77d86d4b8887d64736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "ccipReceive((bytes32,uint64,bytes,bytes,(address,uint256)[]))": {
        "details": "Note ensure you check the msg.sender is the OffRampRouter",
        "params": {
          "message": "CCIP Message"
        }
      },
      "getRouter()": {
        "returns": {
          "_0": "CCIP router address"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "Should indicate whether the contract implements IAny2EVMMessageReceiver e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId This allows CCIP to check if ccipReceive is available before calling it. If this returns false or reverts, only tokens are transferred to the receiver. If this returns true, tokens are transferred and ccipReceive is called atomically. Additionally, if the receiver address does not have code associated with it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.",
        "params": {
          "interfaceId": "The interfaceId to check"
        },
        "returns": {
          "_0": "true if the interfaceId is supported"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "ccipReceive((bytes32,uint64,bytes,bytes,(address,uint256)[]))": {
        "notice": "Called by the Router to deliver a message. If this reverts, any token transfers also revert. The message will move to a FAILED state and become available for manual execution."
      },
      "getRouter()": {
        "notice": "Return the current router"
      },
      "supportsInterface(bytes4)": {
        "notice": "IERC165 supports an interfaceId"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 220,
        "contract": "contracts/MsgBoard.sol:MsgBoard",
        "label": "msgDashboard",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Msg)213_storage)"
      },
      {
        "astId": 222,
        "contract": "contracts/MsgBoard.sol:MsgBoard",
        "label": "msgCount",
        "offset": 0,
        "slot": "1",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint256,t_struct(Msg)213_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Msg)",
        "numberOfBytes": "32",
        "value": "t_struct(Msg)213_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Msg)213_storage": {
        "encoding": "inplace",
        "label": "struct Msg",
        "members": [
          {
            "astId": 208,
            "contract": "contracts/MsgBoard.sol:MsgBoard",
            "label": "from",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 210,
            "contract": "contracts/MsgBoard.sol:MsgBoard",
            "label": "sender",
            "offset": 8,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 212,
            "contract": "contracts/MsgBoard.sol:MsgBoard",
            "label": "message",
            "offset": 0,
            "slot": "1",
            "type": "t_string_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}